<nav class="navbar navbar-default navbar-fixed-top">
	<div class="container">
		<div class="navbar-header">
			<a href="#"  class="navbar-brand">
				Info-Bitcoin
			</a>
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav">
				<li>
					<a href="#">Home</a>
				</li>
				<li>
					<a href="#">About</a>
				</li>
			</ul>
		</div>

	</div>	
</nav>
<!-- Content -->

<div class="container-fluid" role="main">
	<h1>Welcome to InfoCoin</h1>			
</div>


<h4>Current Price: <span id="current_price"></span></h4>
<h4>Rolling Average: <span id="rolling_average"></span> </h4>	


<script type="text/javascript">
	//store the BPI Object
	var bpiList = [];
	var currentPriceEl = document.getElementById("current_price");
	var rollingAverageEl = document.getElementById("rolling_average");
	

	//Stream Observable, get from the url(API coindesk)
	var requestStream = Rx.Observable.just("http://api.coindesk.com/v1/bpi/currentprice.json");	

	//Stream Observable, making plain object from the promise of Response
	var responseStream = requestStream.flatMap(function(requestUrl){
		return Rx.Observable.fromPromise($.getJSON(requestUrl));
	});

	//this stream will be execute each minute, starting when the page is loaded
	var streamByMinute = Rx.Observable.interval(60000).startWith("startup");

	//subscription 
	streamByMinute.subscribe(function(interval){;
		actionResponse();
	});

	//Actions when getting the response
	function actionResponse(){
		//Subscription for responseStream, I wanna watch the objectBpi(Bitcoin price index) and do some stuff Here.
		responseStream.subscribe(function(objectBpi){
			var price = objectBpi.bpi.USD.rate;
			//store the attr rate			
			bpiList.push(price);
			//Show in View
			updateContent(currentPriceEl, price + "$");			
			//When the list have five Prices, then we can calculate the Rolling average.
			if(bpiList.length >= 5){
				calculatingRollingAverage();
			}else{				
				rollingAverageEl.textContent = "Remaining "+ (5- bpiList.length) +"ElementsTo calculate the Rolling average.";
			}						
		});
	}


	function calculatingRollingAverage(){
		var itemsPrice = Rx.Observable.fromArray(bpiList);
		//Getting the prices from the observable list and store of Five on five.
		//Filter, returning when the array have a length of Five Elements
		//and take the last element(Array containing the last 5 Elements)
		//Parse each elements and Parse to Float
		//at the end Calculate Average
		var bufferItems = itemsPrice.bufferWithCount(5,1).
							filter(function(x, idx, obs){
								return x.length == 5;
							}).takeLast(1)
							.map(function(itemsPrice){
								console.log("from Map");
								console.log(itemsPrice);
								return parseFloat(itemsPrice);
							}).average();		

		bufferItems.subscribe(function(rollingAv){
			console.log(rollingAv);
			updateContent(rollingAverageEl, rollingAv + "$");			
		});
	}

	function updateContent(element, text){
		element.textContent = text;
	}

</script>